# Python OOP: Abstraction, Interfaces, and Subclassing

> **â€œThe art of OOP is not just in building objects, but in designing flexible blueprints for them.â€**

---

## ğŸ“š Introduction

Welcome to this Python OOP project on **Abstraction and Advanced Class Design**.
Through a series of hands-on exercises, youâ€™ll explore powerful concepts such as **abstract classes**, **interfaces**, **duck typing**, and **subclassing**.
By the end of these exercises, youâ€™ll be ready to design robust, reusable, and flexible codeâ€”skills that are foundational for any modern Python developer.

---

## ğŸš€ Learning Objectives

- **Abstract Classes:**
  Define common interfaces and enforce method implementation in subclasses using `abc.ABC` and `@abstractmethod`.

- **Interfaces & Duck Typing:**
  Understand and use Pythonâ€™s dynamic â€œif it walks like a duck, itâ€™s a duckâ€ approachâ€”designing code that expects behavior, not type.

- **Subclassing Standard Base Classes:**
  Extend built-in types (e.g., `list`, `dict`, `iterator`) to add custom functionality.

- **Method Overriding:**
  Change or enhance parent class methods to fit new use cases.

- **Multiple Inheritance:**
  Combine features from more than one parent class to build complex, expressive hierarchies.

- **Mixins:**
  Create lightweight, reusable pieces of behavior to â€œmix intoâ€ multiple unrelated classes.

---

## ğŸ§© Key Concepts Explored

- **Abstract Classes & Methods**: Use abstract base classes to define contracts for subclasses and enforce method implementation.
- **Interfaces & Duck Typing**: Focus on what objects can do, not what they are. Functions and methods should accept any object that provides the expected methods/attributes.
- **Subclassing Built-ins**: Extend classes like `list`, `dict`, or `iter` to create custom behaviors for your use case.
- **Method Overriding**: Redefine inherited methods in subclasses to change or enhance their behavior.
- **Multiple Inheritance & Mixins**: Inherit from multiple parent classes to combine features and reuse functionality across unrelated classes. Mixins are designed to be lightweight and composable.
- **Method Resolution Order (MRO)**: Python determines which parentâ€™s method to call using the MRO (see `.mro()`), which avoids ambiguity in complex class hierarchies.

---

## ğŸ‘©â€ğŸ’» What I Practiced

- Designing class hierarchies using abstraction.
- Enforcing contracts via abstract base classes.
- Using duck typing for more flexible, generic code.
- Building custom containers and iterators by subclassing Python built-ins.
- Composing behavior with mixins for code reuse.
- Handling complex class relationships with multiple inheritance.

---

## ğŸ“– Resources

- [Python 3 Object-Oriented Programming](https://realpython.com/python3-object-oriented-programming/)
- [ABC â€” Abstract Base Classes (docs)](https://docs.python.org/3/library/abc.html)
- [Real Python - OOP in Python 3](https://realpython.com/python3-object-oriented-programming/)
- [Corey Schafer - OOP Playlist](https://www.youtube.com/playlist?list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc)
- [sentdex - Python OOP Tutorial](https://www.youtube.com/watch?v=JeznW_7DlB0)

---

## ğŸ† Takeaways

By completing this project, Iâ€™ve gained:
- Confidence in designing with abstraction and interfaces.
- Understanding of Pythonâ€™s approach to â€œinterfacesâ€ and how duck typing empowers flexible code.
- The ability to extend standard classes and use mixins for reusable features.
- The skills to tackle large-scale OOP problems with clear, maintainable solutions.

---

## âœï¸ Author

Josniel Ramos
Student at Holberton School
[GitHub: jota009](https://github.com/jota009)

---
