# Python OOP: Abstraction, Interfaces, and Subclassing

> **“The art of OOP is not just in building objects, but in designing flexible blueprints for them.”**

---

## 📚 Introduction

Welcome to this Python OOP project on **Abstraction and Advanced Class Design**.
Through a series of hands-on exercises, you’ll explore powerful concepts such as **abstract classes**, **interfaces**, **duck typing**, and **subclassing**.
By the end of these exercises, you’ll be ready to design robust, reusable, and flexible code—skills that are foundational for any modern Python developer.

---

## 🚀 Learning Objectives

- **Abstract Classes:**
  Define common interfaces and enforce method implementation in subclasses using `abc.ABC` and `@abstractmethod`.

- **Interfaces & Duck Typing:**
  Understand and use Python’s dynamic “if it walks like a duck, it’s a duck” approach—designing code that expects behavior, not type.

- **Subclassing Standard Base Classes:**
  Extend built-in types (e.g., `list`, `dict`, `iterator`) to add custom functionality.

- **Method Overriding:**
  Change or enhance parent class methods to fit new use cases.

- **Multiple Inheritance:**
  Combine features from more than one parent class to build complex, expressive hierarchies.

- **Mixins:**
  Create lightweight, reusable pieces of behavior to “mix into” multiple unrelated classes.

---

## 🧩 Key Concepts Explored

- **Abstract Classes & Methods**: Use abstract base classes to define contracts for subclasses and enforce method implementation.
- **Interfaces & Duck Typing**: Focus on what objects can do, not what they are. Functions and methods should accept any object that provides the expected methods/attributes.
- **Subclassing Built-ins**: Extend classes like `list`, `dict`, or `iter` to create custom behaviors for your use case.
- **Method Overriding**: Redefine inherited methods in subclasses to change or enhance their behavior.
- **Multiple Inheritance & Mixins**: Inherit from multiple parent classes to combine features and reuse functionality across unrelated classes. Mixins are designed to be lightweight and composable.
- **Method Resolution Order (MRO)**: Python determines which parent’s method to call using the MRO (see `.mro()`), which avoids ambiguity in complex class hierarchies.

---

## 👩‍💻 What I Practiced

- Designing class hierarchies using abstraction.
- Enforcing contracts via abstract base classes.
- Using duck typing for more flexible, generic code.
- Building custom containers and iterators by subclassing Python built-ins.
- Composing behavior with mixins for code reuse.
- Handling complex class relationships with multiple inheritance.

---

## 📖 Resources

- [Python 3 Object-Oriented Programming](https://realpython.com/python3-object-oriented-programming/)
- [ABC — Abstract Base Classes (docs)](https://docs.python.org/3/library/abc.html)
- [Real Python - OOP in Python 3](https://realpython.com/python3-object-oriented-programming/)
- [Corey Schafer - OOP Playlist](https://www.youtube.com/playlist?list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc)
- [sentdex - Python OOP Tutorial](https://www.youtube.com/watch?v=JeznW_7DlB0)

---

## 🏆 Takeaways

By completing this project, I’ve gained:
- Confidence in designing with abstraction and interfaces.
- Understanding of Python’s approach to “interfaces” and how duck typing empowers flexible code.
- The ability to extend standard classes and use mixins for reusable features.
- The skills to tackle large-scale OOP problems with clear, maintainable solutions.

---

## ✍️ Author

Josniel Ramos
Student at Holberton School
[GitHub: jota009](https://github.com/jota009)

---
